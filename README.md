# HpscLab

숭실대학교 고성능컴퓨팅 연구실 정준영연구생 연구과제 <(heterogeneous computing)> 겸 공부 정리.

쿠다를 공부해 보자.

### window AES알고리즘 - 리눅스로 바꾸기

22/01/18우분투 설치 후 쿠다환경 세팅중 이슈발생.

공식문서 보면서 설치하는중에 설치 오류로 19일 우분투 포맷후 재설치 필요.

### 우분투 20 LTS 버전 설치 완료. (듀얼부팅 세팅)

## 쿠다 환경세팅 완료.

방법

https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=20.04&target_type=runfile_local

최신 문서 참고.

+엔디비아 드라이버가 설치되어있지않다면 설치 필요.

test파일 실험중 (성공)

쿠다 버전 11.6(가장 최신 버전) 컴파일 정상작동하나, 실행의 문제 있음(nvcc컴파일시 실행파일이 만들어 지지만 실행하면 결과로 이상한 값이 나온다.)

하위버전으로 변경 필요한듯하다.

++ 가장 최신 버전으로 올린게 문제였음. 너무 최신버전으로 쿠다를 설치하면 실행이 안되는것 같음.

### 우분투 20 LTS버전 쿠다 설치 주의사항

#### 1. ndivia 드라이버부터 설치해야한다. (이때 자동 설치로 하는것이 좋다. 드라이버 버전을 쿠다랑 호환 안되는것을 지정설치하면 안된다.)

#### 2. cuda 설치 할때 드라이버 체크하면 안된다. (1에서 이미 설치하고 시작하기 때문이다.)

#### 3. cuda 버전 꼭 최신말고 cudnn이랑 호환되는 버전을 골라서 설치하자.

#### 4. cudnn 설치할때 경로 복사 잘하자.

## CUDA 시작해보기 (refernce by "CUDA by EXAMPLE")

### 1 병렬 프로세싱의 시대

최근 몇 년간 컴퓨팅 산업에서 광범위한 것들이 병렬컴퓨터로 대체됨. 2010년대 이후로는 싱글코어 컴퓨터를 찾아보기 힘들어 질 것이다. (저가의 넷북들도 기본 코어가 8개는 된다.)

#### 1.1 중앙처리장치

1980년대 CPU는 약 1MHz 내부 클럭 속도로 작동 하였다. 2010년대에느 대부분의 개인용 컴퓨터 기본 데스크톱도 1GHz ~ 4GHz의 속도 (약 1000배차이)를 보인다. CPU클럭속도의 증가가 컴퓨팅 성능향상의 유일한 방안은 아니었지만, 성능 향상의 주축이었다.

그러나 현대에 들어서 클럭향상에 근본적 제한이 생기기 시작했다.

1. 전력과 열의 제한
2. 물리적 트렌지스터 크기가 한계에 도달.

++ 이외에도 여러 제한사항이 발생함.

이때, 개인용컴퓨터세계가 아닌, 슈퍼컴퓨터세계에서는 단일 프로세서 뿐만 아니라, 프로세스의 개수 또한 꾸준히 증가시켜면서 성능에서 꾸준한 향상을 이뤄냄.

여기서 개인용 컴퓨터의 연산능력 향상에 영감을 얻을 수 있었다. 단일 프로세싱의 코어성능 향상만 고려하는것이 아니라, 하나의 개인용 컴퓨터에 하나 이상의 코어를 장착해 보는 것이다.

해당 방법으로 클럭속도를 지속적으로 증가시킬 필요없이 개인용 컴퓨터의 성능향상도 이뤄낼수 잇을것이다.

2005년 이후부터 CPU제조업체들은 여러 코어를 탑재한 프로세서들을 내놓기 시작함. 즉 멀티코어의 시대가 도래.

요즘에는 오히려 단일코어를 사용하는 개인용 컴퓨터를 찾아보기 어렵다.

#### 1.2 GPU 컴퓨팅

1980년대 후반 MS에 윈도우 운영체제와 같은 그래픽기반 운영체제가 등장하면서 새로운 종류의 프로세서 시장이 창출 되었다. 사용자들은 개인용 컴퓨터를 위한 2D 디스플레이 가속기를 구입하기 시작했다.

- 가속기 개념 - 특정 작업을 전문으로 하는 장치 및 하드웨어라고 보면된다. 즉 2D디스플레이 가속기는 윈도우의 그래픽 기반운영체제에서 사용자에게 2D디스플레이 작업을 랜더링해서 보여주기 위해 나온 보조장치라고 볼 수 있다.

이러한 가속기들은 그래픽기반의 운영체제 화면 정보와 사용성을 보조하기 위한 하드웨어 비트맵연산을 제공했다.

이시점에서 실리콘그래픽스회사가 3차원 그래픽스 사용을 대중화 시키고 툴을 제공.
OpenGL이라는 라이브러리를 배포했는데, 통해 3D 그래픽스 어플리케이션을 작성하기 위한 플랫폼 독립적인 표준 그래픽 라이브리러로 자리잡음

1990년대 중반에 들어서는 3D그래픽스를 이용한 소비자 어플리케이션의 수요가 급속히 증가합. 이유로 게임이 있다. 1인칭 3D환경을 제공하는 게임의 히트는 3D그래픽발전에 도화선이 되었다.
이때부터 각 하드웨어 회사가 그래픽 가속기들을 발매하기 시작했다.

2001년 NVIDA에서 처음 지포스 3시리즈를 발매했는데, 이는 Direct X 8.0의 새 표준을 구현하기 위한 첫번째 칩이었고, 하드웨어가 프로그래밍이 가능한 버텍스와 픽셀 셰이딩 단계들을 모두 포함했기에, 이때부터 개발자들이 GPU상에서 수행되는 정밀 계산의 일부를 조작할 수 있었다.

간략하게 정리하자면, GPU발매 이후 개발자들은 단순 렌더링 목적 이상으로 그래픽스 하드웨어를 사용할 가능성에 대해 관심을 가졌다. 그러나 초창기 GPU의 접근법은 OpenGL, DirectX를 통한 상호작용 외에는 없었다. 그렇기에 이때 그래픽스 API를 통한 범용계산 방법을 강구했다. 이때 개발자들은 GPU랜더링 작업의 데이터를 주어서 마치 비랜더링작업을 하나의 일반 랜더링처럼 수행하도록 처리했는데, 기발한 방법이지만 유연하지 못했다. 왜냐하면 오직 소수의 입력색상과 소수의 텍스처 구상 데이터만 입력받을수 있었기 떄문이다. (결국엔 랜더링 작업이기 떄문)

그러다 2006년 첫번째 쿠다 아키텍처가 발표되었다. 쿠다 컴파일러와 쿠다 아키텍처를 통해 GPU실행유닛들은 메모리에 대한 임의의 읽기,쓰기가, 캐시접근이 가능해졌다.

- 손글씨 공부내용은 pdf파일을 따로 올렸다.

#### 1.3 기초 CUDA 프로그래밍

+cuda 설치는 윗 파트 참고

첫번째 쿠다 코드를 작성해 보자.

<code>
__global__ void add (int a, int b, int *c){
    c* = a + b;
}

int main(){
int c;
int\* dev_c;

cudaMalloc((void\*\*)&dev_c,sizeof(int));

add<<<1,1>>>(2,7,dev_c);

cudaMemcpy(&c,dev_c,sizeof(int),cudaMemcpyDeviceToHost);

printf("2 + 7 = %d\n",c);

return 0;

}
</code>

가장 중요한 포인트는 **global**지시자다. 해당 지시자를 통해 쿠다 컴파일러는 디바이스에서 실행될 코드임을 알 수있다.
그리고 디바이스내에서 사용할 변수에 대한 메모리 할당을 해 주어야 한다.
